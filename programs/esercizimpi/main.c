#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <math.h>
#include <time.h>
#include "exercises.h"


/* You have a 2D matrix A, filled with randomm elements. The
 * number of rows and columns can be different (get them from
 * argv). The matrix is generated by rank 0. After the matrix is
 * generated you perform s iterations (get s through argv). At
 * each iteration s we compute a new matrix A such that the value
 * in position (i,j) is the sum of the values in the position
 * (i-1,j), (i,j-1), (i+1,j), (i,j+1), i.e. perform a
 * convolution. NOTE: Do this by allocating no more than two
 * matrices, regardless of the number of iterations you need.
 * Also, manage the case where the number of elements in the
 * matrix is larger than the number of processes. */
int main(int argc, char** argv) {
    int rank, comm_sz;
    int i = 1;
    int m = atoi(argv[1]); /* Rows of A */
    int n = atoi(argv[2]); /* Columns of A */
    int s = m * n;

    MPI_Init(NULL, NULL);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &comm_sz);
    int root = 0;

    if (s % comm_sz != 0) {
        printf("[*]ERROR, size of vector must be evenly divisible by number of processes\n");
        fflush(stdout);
        MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);
    }

    int local_sz = s / comm_sz;
    int scatter_recv[local_sz];
    int zero_scatter_recv[local_sz];

    if (rank == root) {
        int* A = create_random_vector(s);
        int* B = create_zero_vector(s);
        MPI_Scatter(A, local_sz,
                    MPI_INT, scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
        MPI_Scatter(B, local_sz,
                    MPI_INT, zero_scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
        free(A);
        free(B);
    } else {
        MPI_Scatter(NULL, local_sz,
                    MPI_INT, scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
        MPI_Scatter(NULL, local_sz,
                    MPI_INT, zero_scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
    }

    printf("scatter_recv of process %d: ", rank);
    print_mat(&scatter_recv[0], &i, &local_sz);
    MPI_Barrier(MPI_COMM_WORLD);
    printf("zero_scatter_recv of process %d: ", rank);
    print_mat(&zero_scatter_recv[0], &i, &local_sz);


    MPI_Finalize();
    return EXIT_SUCCESS;
}
