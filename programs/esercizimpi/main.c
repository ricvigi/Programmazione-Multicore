#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <math.h>
#include <time.h>
#include "exercises.h"


/* You have a 2D matrix A, filled with random elements. The
 * number of rows and columns can be different (get them from
 * argv). The matrix is generated by rank 0. After the matrix is
 * generated you perform s iterations (get s through argv). At
 * each iteration s we compute a new matrix A such that the value
 * in position (i,j) is the sum of the values in the position
 * (i-1,j), (i,j-1), (i+1,j), (i,j+1), i.e. perform a
 * convolution. NOTE: Do this by allocating no more than two
 * matrices, regardless of the number of iterations you need.
 * Also, manage the case where the number of elements in the
 * matrix is larger than the number of processes. */
int main(int argc, char** argv) {
    int rank, comm_sz;
    int i = 1;
    int m = atoi(argv[1]); /* Rows of A */
    int n = atoi(argv[2]); /* Columns of A */
    int K = atoi(argv[3]); /* Number of iterations */
    int s = m * n;

    MPI_Init(NULL, NULL);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &comm_sz);

    /* For this implementation we require root to be 0 */
    const int root = 0;
    const int tail = comm_sz - 1;

    if (s % comm_sz != 0) {
        printf("[*]ERROR, size of vector must be evenly divisible by number of processes\n");
        fflush(stdout);
        MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);
    }
    if (comm_sz >= s) {
        printf("[*]ERROR, you have too many processes\n");
        fflush(stdout);
        MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);
    }

    int local_sz = s / comm_sz;
    int scatter_recv[local_sz];
    int zero_scatter_recv[s];

    if (rank == root) {
        int* A = create_random_vector(s);
        print_mat(A, &i, &s);
        MPI_Scatter(A, local_sz,
                    MPI_INT, scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
        free(A);
    } else {
        MPI_Scatter(NULL, local_sz,
                    MPI_INT, scatter_recv,
                    local_sz, MPI_INT,
                    root, MPI_COMM_WORLD);
    }

    int recv0[local_sz];
    int recv1[local_sz];
    const int eol = local_sz - 1;
    for (int k = 0; k < K; k++) {
        /* Code for root process */
        if (rank == root) {
            int dest = rank + 1;
            MPI_Sendrecv(scatter_recv, local_sz,
                         MPI_INT, dest, 0, recv0,
                         local_sz, MPI_INT, dest,
                         0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int i = 0; i < local_sz; i++) {
                if (i == 0) {
                    int DOWN = recv0[i];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = DOWN + RIGHT;
                }
                if ( i == eol) {
                    int DOWN = recv0[i];
                    int LEFT = scatter_recv[i - 1];
                    zero_scatter_recv[i] = DOWN + LEFT;
                } else {
                    int DOWN = recv0[i];
                    int LEFT = scatter_recv[i - 1];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = DOWN + LEFT + RIGHT;
                }
            }
        } else if (rank == tail) { /* Code for tail process */
            int dest = rank - 1;
            MPI_Sendrecv(scatter_recv, local_sz,
                         MPI_INT, dest, 0, recv0,
                         local_sz, MPI_INT, dest,
                         0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int i = 0; i < local_sz; i++) {
                if (i == 0) {
                    int UP = recv0[i];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = UP + RIGHT;
                }
                if ( i == eol) {
                    int UP = recv0[i];
                    int LEFT = scatter_recv[i - 1];
                    zero_scatter_recv[i] = UP + LEFT;
                } else {
                    int UP = recv0[i];
                    int LEFT = scatter_recv[i - 1];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = UP + LEFT + RIGHT;
                }
            }
        } else { /* Other processes */
            int dest0 = rank - 1;
            int dest1 = rank + 1;
            MPI_Sendrecv(scatter_recv, local_sz,
                         MPI_INT, dest0, 0, recv0,
                         local_sz, MPI_INT, dest0,
                         0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            MPI_Sendrecv(scatter_recv, local_sz,
                         MPI_INT, dest1, 0, recv1,
                         local_sz, MPI_INT, dest1,
                         0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int i = 0; i < local_sz; i++) {
                if (i == 0) {
                    int UP = recv0[i];
                    int DOWN = recv1[i];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = UP + DOWN + RIGHT;
                }
                if ( i == eol) {
                    int UP = recv0[i];
                    int DOWN = recv1[i];
                    int LEFT = scatter_recv[i - 1];
                    zero_scatter_recv[i] = UP + DOWN + LEFT;
                } else {
                    int UP = recv0[i];
                    int DOWN = recv1[i];
                    int LEFT = scatter_recv[i - 1];
                    int RIGHT = scatter_recv[i + 1];
                    zero_scatter_recv[i] = UP + DOWN + LEFT + RIGHT;
                }
            }
        }
        for (int i = 0; i < local_sz; i++) {
            scatter_recv[i] = zero_scatter_recv[i];
            zero_scatter_recv[i] = 0;
        }
    }
    // printf("process %d: ", rank);
    // print_mat(scatter_recv, &i, &local_sz);
    // fflush(stdout);
    MPI_Gather(scatter_recv, local_sz, MPI_INT,
               zero_scatter_recv, local_sz, MPI_INT,
               root, MPI_COMM_WORLD);
    if (rank == root) {
        print_mat(zero_scatter_recv, &m, &n);
    }


    MPI_Finalize();
    return EXIT_SUCCESS;
}
